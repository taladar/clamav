Description: Fix out-of-bounds read in PDF parser
 Fix for an out-of-bounds read in the PDF parser when initializing
 aes crypto routines that may result in a crash.
 .
 Bug found by OSS-Fuzz.
 .
 Also added checks for the arc4 init routine to mitigate the risk of a
 similar issue.
Origin: https://github.com/Cisco-Talos/clamav-devel/commit/bca52dfb4349ffe23b613690f8789691f766444c
Author: Micah Snyder <micasnyd@cisco.com>
Author: Utkarsh Gupta <utkarsh@debian.org>
Last-Update: 2020-05-19

--- a/libclamav/arc4.c
+++ b/libclamav/arc4.c
@@ -27,11 +27,16 @@
 #include "arc4.h"
 #include <string.h>
 
-void arc4_init(struct arc4_state *a, const uint8_t *key, unsigned keylength)
+bool arc4_init(struct arc4_state *a, const uint8_t *key, unsigned keylength)
 {
     unsigned i;
     uint8_t j;
-    uint32_t *S = &a->S[0];
+    uint32_t *S;
+
+    if (NULL == a || NULL == key || 0 == keylength)
+        return false;
+
+    S = &a->S[0];
 
     for (i=0; i < 256;i ++)
 	S[i] = i;
@@ -42,6 +47,7 @@
 	S[j] = tmp;
     }
     a->i = a->j = 0;
+    return true;
 }
 
 void arc4_apply(struct arc4_state *s, uint8_t *data, unsigned len)
--- a/libclamav/arc4.h
+++ b/libclamav/arc4.h
@@ -19,6 +19,8 @@
  *  MA 02110-1301, USA.
  */
 
+#include <stdbool.h>
+
 #include "clamav-types.h"
 struct arc4_state {
     /* really just 8 bit, but it is faster if reads are aligned */
@@ -26,5 +28,5 @@
     uint8_t i, j;
 };
 
-void arc4_init(struct arc4_state *a, const uint8_t *key, unsigned keylength);
+bool arc4_init(struct arc4_state *a, const uint8_t *key, unsigned keylength);
 void arc4_apply(struct arc4_state *s, uint8_t *data, unsigned len);
--- a/libclamav/pdf.c
+++ b/libclamav/pdf.c
@@ -1080,8 +1080,9 @@
     int nrounds;
 
     cli_dbgmsg("aes_decrypt: key length: %d, data length: %zu\n", key_n, *length);
-    if (key_n > 32) {
-        cli_dbgmsg("aes_decrypt: key length is %d!\n", key_n*8);
+    if (!(key_n == 16 || key_n == 24 || key_n == 32)) {
+        cli_dbgmsg("aes_decrypt: invalid key length: %u!\n", key_n * 8);
+        noisy_warnmsg("aes_decrypt: invalid key length: %u!\n", key_n * 8);
         return;
     }
 
@@ -1158,7 +1159,12 @@
     struct arc4_state arc4;
 
     if (!length || !*length || !in) {
-        noisy_warnmsg("decrypt_any: decrypt failed for obj %u %u\n", id>>8, id&0xff);
+        noisy_warnmsg("decrypt_any: decrypt failed for obj %u %u:  Invalid arguments.\n", id >> 8, id & 0xff);
+        return NULL;
+    }
+
+    if (NULL == pdf->key || 0 == pdf->keylen) {
+        noisy_warnmsg("decrypt_any: decrypt failed for obj %u %u:  PDF key never identified.\n", id >> 8, id & 0xff);
         return NULL;
     }
 
@@ -1199,7 +1205,10 @@
     case ENC_V2:
         cli_dbgmsg("cli_pdf: enc is v2\n");
         memcpy(q, in, *length);
-        arc4_init(&arc4, result, n);
+        if (false == arc4_init(&arc4, result, n)) {
+            noisy_warnmsg("decrypt_any: failed to init arc4\n");
+            return NULL;
+        }
         arc4_apply(&arc4, q, (unsigned)*length); /* TODO: may truncate for very large lengths */
 
         noisy_msg(pdf, "decrypt_any: decrypted ARC4 data\n");
@@ -2793,7 +2802,10 @@
         if (R == 2) {
             /* 7.6.3.3 Algorithm 4 */
             memcpy(data, key_padding, 32);
-            arc4_init(&arc4, (const uint8_t *)(pdf->key), pdf->keylen);
+            if (false == arc4_init(&arc4, (const uint8_t *)(pdf->key), pdf->keylen)) {
+                noisy_warnmsg("decrypt_any: failed to init arc4\n");
+                return;
+            }
             arc4_apply(&arc4, (uint8_t *)data, 32);
             dbg_printhex("computed U (R2)", data, 32);
             if (!memcmp(data, U, 32))
@@ -2812,7 +2824,10 @@
             cl_hash_data("md5", d, 32 + pdf->fileIDlen, result, NULL);
             memcpy(data, pdf->key, len);
 
-            arc4_init(&arc4, (const uint8_t *)data, len);
+            if (false == arc4_init(&arc4, (const uint8_t *)data, len)) {
+                noisy_warnmsg("decrypt_any: failed to init arc4\n");
+                return;
+            }
             arc4_apply(&arc4, result, 16);
             for (i=1;i<=19;i++) {
                 unsigned j;
@@ -2820,7 +2835,10 @@
                 for (j=0;j<len;j++)
                     data[j] = pdf->key[j] ^ i;
 
-                arc4_init(&arc4, (const uint8_t *)data, len);
+                if (false == arc4_init(&arc4, (const uint8_t *)data, len)) {
+                    noisy_warnmsg("decrypt_any: failed to init arc4\n");
+                    return;
+                }
                 arc4_apply(&arc4, result, 16);
             }
 
